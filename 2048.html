<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game 2048</title>
    <link rel="stylesheet" href="2048.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="header-2048">
        <a href="trochoi.html" class="back-link">
            <button class="game-btn">Quay lại</button>
        </a>
        <h1>2048</h1>
        <p>Kết hợp các ô số để đạt được 2048!</p>
    </header>

    <main>
        <div id="game-container">
            <div id="game-info">
                <p>Điểm: <span id="score">0</span></p>
                <div id="status"></div>
                <button id="reset-btn" class="game-btn">Chơi lại</button>
            </div>
            <div id="board"></div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const board = document.getElementById('board');
            const scoreSpan = document.getElementById('score');
            const statusDiv = document.getElementById('status');
            const resetBtn = document.getElementById('reset-btn');
            
            let grid = Array(4).fill(null).map(() => Array(4).fill(0));
            let score = 0;
            let gameActive = true;
            
            const createBoard = () => {
                board.innerHTML = '';
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.innerText = grid[i][j] === 0 ? '' : grid[i][j];
                        cell.style.backgroundColor = getTileColor(grid[i][j]);
                        board.appendChild(cell);
                    }
                }
            };
            
            const getTileColor = (value) => {
                const colors = {
                    0: '#3c3c54', 2: '#eee4da', 4: '#ede0c8', 8: '#f2b179',
                    16: '#f59563', 32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72',
                    256: '#edcc61', 512: '#edc850', 1024: '#edc53f', 2048: '#edc22e'
                };
                return colors[value] || '#ff0080';
            };
            
            const addRandomTile = () => {
                if (!isBoardFull()) {
                    let emptyTiles = [];
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            if (grid[i][j] === 0) {
                                emptyTiles.push({ row: i, col: j });
                            }
                        }
                    }
                    if (emptyTiles.length > 0) {
                        const randomTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
                        grid[randomTile.row][randomTile.col] = Math.random() < 0.9 ? 2 : 4;
                    }
                }
            };
            
            const isBoardFull = () => {
                return !grid.some(row => row.includes(0));
            };

            const slide = (row) => {
                let arr = row.filter(val => val);
                let missing = 4 - arr.length;
                let zeros = Array(missing).fill(0);
                arr = zeros.concat(arr);
                return arr;
            };

            const combine = (row) => {
                for (let i = 3; i > 0; i--) {
                    let a = row[i];
                    let b = row[i - 1];
                    if (a === b) {
                        row[i] = a + b;
                        score += row[i];
                        row[i - 1] = 0;
                    }
                }
                return row;
            };

            const moveRight = () => {
                let changed = false;
                for (let i = 0; i < 4; i++) {
                    let oldRow = [...grid[i]];
                    let newRow = combine(slide(grid[i]));
                    grid[i] = newRow;
                    if (JSON.stringify(oldRow) !== JSON.stringify(newRow)) {
                        changed = true;
                    }
                }
                return changed;
            };
            
            const moveLeft = () => {
                let changed = false;
                for (let i = 0; i < 4; i++) {
                    let oldRow = [...grid[i]];
                    let row = grid[i].filter(val => val);
                    let missing = 4 - row.length;
                    let zeros = Array(missing).fill(0);
                    row = row.concat(zeros);
                    for (let j = 0; j < 3; j++) {
                        if (row[j] === row[j + 1]) {
                            row[j] += row[j + 1];
                            score += row[j];
                            row[j + 1] = 0;
                        }
                    }
                    row = row.filter(val => val).concat(zeros);
                    grid[i] = row;
                    if (JSON.stringify(oldRow) !== JSON.stringify(row)) {
                        changed = true;
                    }
                }
                return changed;
            };

            const moveUp = () => {
                let changed = false;
                let newGrid = Array(4).fill(null).map(() => Array(4).fill(0));
                for (let j = 0; j < 4; j++) {
                    let col = [grid[0][j], grid[1][j], grid[2][j], grid[3][j]].filter(val => val);
                    for (let i = 0; i < 3; i++) {
                        if (col[i] === col[i + 1]) {
                            col[i] += col[i + 1];
                            score += col[i];
                            col[i + 1] = 0;
                        }
                    }
                    col = col.filter(val => val);
                    let missing = 4 - col.length;
                    let zeros = Array(missing).fill(0);
                    col = col.concat(zeros);
                    for (let i = 0; i < 4; i++) {
                        if (newGrid[i][j] !== col[i]) changed = true;
                        newGrid[i][j] = col[i];
                    }
                }
                grid = newGrid;
                return changed;
            };

            const moveDown = () => {
                let changed = false;
                let newGrid = Array(4).fill(null).map(() => Array(4).fill(0));
                for (let j = 0; j < 4; j++) {
                    let col = [grid[0][j], grid[1][j], grid[2][j], grid[3][j]].filter(val => val);
                    col.reverse();
                    for (let i = 0; i < 3; i++) {
                        if (col[i] === col[i + 1]) {
                            col[i] += col[i + 1];
                            score += col[i];
                            col[i + 1] = 0;
                        }
                    }
                    col = col.filter(val => val);
                    let missing = 4 - col.length;
                    let zeros = Array(missing).fill(0);
                    col = col.concat(zeros);
                    col.reverse();
                    for (let i = 0; i < 4; i++) {
                        if (newGrid[i][j] !== col[i]) changed = true;
                        newGrid[i][j] = col[i];
                    }
                }
                grid = newGrid;
                return changed;
            };
            
            const checkGameOver = () => {
                if (isBoardFull()) {
                    let movesPossible = false;
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 4; j++) {
                            const current = grid[i][j];
                            if (j < 3 && current === grid[i][j+1]) movesPossible = true;
                            if (i < 3 && current === grid[i+1][j]) movesPossible = true;
                        }
                    }
                    if (!movesPossible) {
                        gameActive = false;
                        statusDiv.innerText = 'Game Over!';
                    }
                }
            };

            const handleKeyDown = (event) => {
                if (!gameActive) return;

                let moved = false;
                switch (event.key) {
                    case 'ArrowUp':
                        moved = moveUp();
                        break;
                    case 'ArrowDown':
                        moved = moveDown();
                        break;
                    case 'ArrowLeft':
                        moved = moveLeft();
                        break;
                    case 'ArrowRight':
                        moved = moveRight();
                        break;
                    default:
                        return;
                }

                if (moved) {
                    addRandomTile();
                    createBoard();
                    scoreSpan.innerText = score;
                    checkGameOver();
                }
            };

            const resetGame = () => {
                grid = Array(4).fill(null).map(() => Array(4).fill(0));
                score = 0;
                gameActive = true;
                scoreSpan.innerText = score;
                statusDiv.innerText = '';
                addRandomTile();
                addRandomTile();
                createBoard();
            };

            resetBtn.addEventListener('click', resetGame);
            document.addEventListener('keydown', handleKeyDown);

            // Bắt đầu game
            addRandomTile();
            addRandomTile();
            createBoard();
        });
    </script>
</body>
</html>